---
title: "Getting Started with the semtree package"
author: "Andreas M. Brandmaier"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting Started with the semtree package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Load the Package

We first load the `semtree` package and the `OpenMx` package for specifying our SEM.

```{r setup}
library(semtree)
library(OpenMx)
```

## Simulate data

Now, we simulate some data from a linear latent growth curve model of educational attainment over time (that is, a random intercept and random slope over time). The dataset will be called `growth_data`. The dataset contains five observations for each individual (`X1` to `X5`) and two predictors representing children's `SES` (low/high) and the `preschool quality`. 

```{r simdata}
set.seed(23)
N <- 1000
M <- 5
icept <- rnorm(N, 10, sd = 4)
slope <- rnorm(N, 3, sd = 1.2)
ses <- factor(sample(c("low", "high"), size = N, replace = TRUE))
preschool_quality <- sample(c(1:5), N, TRUE)
loadings <- 0:4
x <-
  (slope + as.numeric(ses) * 5) %*% t(loadings) + 
  matrix(rep(icept+preschool_quality+as.numeric(ses), each = M), byrow = TRUE, ncol = M) + 
  rnorm(N * M, sd = .08)
growth_data <- data.frame(x, factor(ses), ordered(preschool_quality))
names(growth_data) <- c(paste0("X", 1:M), "SES","Preschool Quality")
```

## Specify an OpenMx model

Now, we specify a linear latent growth curve model using OpenMx's path specification. The model has five observed variables. Residual variances are assumed to be identical over time.

```{r}
manifests <- names(growth_data)[1:5]
growthCurveModel <- mxModel("Linear Growth Curve Model Path Specification",
    type="RAM",
       manifestVars=manifests,
    latentVars=c("intercept","slope"),
    mxData(growth_data, type="raw"),
    # residual variances
    mxPath(
        from=manifests,
        arrows=2,
        free=TRUE,
        values = c(.1, .1, .1, .1, .1),
        labels=c("residual","residual","residual","residual","residual")
    ),
    # latent variances and covariance
    mxPath(
        from=c("intercept","slope"),
        arrows=2,
        connect="unique.pairs",
        free=TRUE,
        values=c(2, 0, 1),
        labels=c("vari", "cov", "vars")
    ),
    # intercept loadings
    mxPath(
        from="intercept",
        to=manifests,
        arrows=1,
        free=FALSE,
        values=c(1, 1, 1, 1, 1)
    ),
    # slope loadings
    mxPath(
        from="slope",
        to=manifests,
        arrows=1,
        free=FALSE,
        values=c(0, 1, 2, 3, 4)
    ),
    # manifest means
    mxPath(
        from="one",
        to=manifests,
        arrows=1,
        free=FALSE,
        values=c(0, 0, 0, 0, 0)
    ),
    # latent means
    mxPath(
        from="one",
        to=c("intercept", "slope"),
        arrows=1,
        free=TRUE,
        values=c(1, 1),
        labels=c("meani", "means")
    )
) # close model

# fit the model to the entire dataset
growthCurveModel <- mxRun(growthCurveModel)
```

## Run a tree

Now, we grow a SEM tree using the `semtree` function, which takes the model and the dataset as input. If not specified otherwise, SEM tree will assume that all variables in the dataset, which are not observed variables in the dataset are potential predictors.

```{r message=FALSE,warning=FALSE,results="hide"}
tree <- semtree(model = growthCurveModel, 
                data = growth_data)
```

## Plotting

Once the tree is grown, we can plot it:

```{r}
plot(tree)
```

## Table

We can also obtain the parameter estimates for each leaf (terminal node) of the tree. Here we use knitr to pretty print the table:

```{r}
knitr::kable(
  toTable(tree)
)
```

## Pruning

Large trees can be pruned back to display only the first few levels of splits. The argument `max.depth` determines the maximal depth of the resulting tree by counting the maximal number of decision nodes until a leaf is reached. For example, `max.depth=1` results in trees that only show one or zero decision nodes.

```{r}
plot( prune(tree, max.depth=1))
```

# Hyper-parameters

There are various (hyper)parameters that govern the tree growing process. These hyperparameters can be adjusted by a `semtree.control` object that can be passed to the `semtree()` function. For example, the following control object specifies that:

- the significance level for the likelihood ratio tests to determine splitting is set to 1% (instead of the default 5%),
- the minimum number of cases in each leaf needs to be 25 if further splits should be investigated
- the maximum depth of the tree is 5 decisions
- Bonferroni-correction is used when determining significance of splits

```{r}
tree_control = semtree.control(alpha = 0.01,
                          min.N = 25,
                          max.depth = 5,
                          bonferroni = TRUE)
```

Here is a tree that is grown using the adjusted hyper-parameters in `tree_control`.

```{r}
tree <- semtree(model = growthCurveModel, 
                data = growth_data,
                control = tree_control)

plot(tree)
```